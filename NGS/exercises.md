# Exercises - Introduction to NGS Data Analysis

**Note** The exercises presented in this course are adapted from Daniel Sobral material course @ IGC from the [Git Hub](https://github.com/GTPB/ELB18F) and from the [on line course](http://www.ngscourse.org/).

> ## FASTQ files


**Exercise 1**: Calculate the probability of error of the bases of the following read in the fastq format:

	@SRR022885.1 BI:080102_SL-XAR_0001_FC201E9AAXX:6:1:752:593/1
	CGTACCAATTATTCAACGTCGCCAGTTGCTTCATGT
	+
	IIIIIIIIII>IIIIIII@IIII.I+I>35I0I&+/

**NOTE**: Phred+33 (Sanger fastq) is the current standard format. Nonetheless, with older illumina data (before 2009) preferred to start at the character '@' (ASCII: 64) instead of '!'. This Phred+64 format is the old illumina fastq. Some tools (like FastQC) can infer the format, while in others you need to specify.

**Exercise 2**: What is the probability of error of the first base of the read?
<details><summary>Click Here to see the answer</summary><p>
The base quality character is 'I', which corresponds to the decimal 73 in the ASCII table. Q = 73-33 = 40. P(40) = 10^(-40/10) = 10^-4 = 0.01% error.
</p></details>

<br/>

**Exercise 3**: What is the probability of error of the last base of the read?
<details><summary>Click Here to see the answer</summary><p>
The base quality character is '/', which corresponds to the decimal 47 in the ASCII table. Q = 47-33 = 14. P(14) = 10^(-14/10) = 10^-1.4 ~= 4% error.
</p></details>
 <br/>

**Exercise 4**: If all bases of a ficticious machine had a Q=20 (1% probability of error), what would be the probability that one 100bp read from that machine would be completely correct?
<details><summary>Click Here to see the answer</summary><p>
P(correct)=(0.99)^100 ~= 36.6%!

This serves to exemplify that most reads in current sequencing machines are likely to have at least one base incorrect.
</p></details>
<br/>

Many sequencing machines can read both ends of a fragment. In this case, the machine will generate two **paired** fastq files, one with the forward reads and another with the reverse reads. You can find an example of this in the folder (files)[https://github.com/CarinaSilva/Curso-Int-NGS/tree/master/NGS/Files] where fastq file paired_end_example_1 contains the forward reads and paired_end_example_2 the reverse reads. These fastq are paired because the reads for the same fragment are in the same order in the two files. For example, the first read in the forward fastq correponds to the forward reading of the same fragment as the first read in the reverse fastq.


**Exercise 5**: Inside the folder files you can see several compressed fastq files. Uncompress the fastq files paired_end_example_1.fastq.gz and paired_end_example_2.fastq.gz that are in the folder files. Open the uncompressed fastq files using any text editor (eg. kate). Can you see a relationship betweem the reads in both files?

Create an empty  directory to work in the exercise and copy or download the raw data to it:

```{r}

mkdir quality_control
cd quality_control gunzip paired_end_example_1.fastq.gz  
gunzip paired_end_example_2.fastq.gz

# Use the command head to have a view of the first lines of the file

head paired_end_example_1.fastq.gz

# Use the command wc to count how many reads are in the file (remember you have to divide by 4)

wc -l paired_end_example_1.fastq
```

<details><summary>Click Here to see the answer</summary><p>


The read identifiers are the same, in the same order (though the sequences are not). This is because they are readings of the same fragment, one (_1) in the forward and another (_2) in the reverse direction. Often the indication of forward and reverse is in the identifier itself.

</p></details>
<br/>
<br/>


> ## Quality Control (QC)

High Throughput Sequencing machines read thousands or millions of sequences in parallel. As you can imagine, this usually generates large fastq files, with millions of lines. Manually inspecting the quality of each read is out of the question. Specialized software has been developed to provide quality measures for fastq files generated by HTS machines. [FastQC](http://www.bioinformatics.babraham.ac.uk/projects/fastqc/) is a popular program to generate quality reports on fastq data. In fact, this is usually the first thing you should do once you receive a new dataset. FastQC reports provide a series of plots that allow the user to assess the overall quality of their raw data and detect potential biases and problems. 


Some plots indicate distribution of base qualities along the length of reads. At least for illumina data, on average the quality of each base tends to decrease along the length of the read. 


Other plots indicate biases in nucleotidic content of reads, either globally (such as %GC plots), or positionally. Global bias in nucleotidic content can be useful to search for signs of contaminants. On the other hand, positional bias are useful to detect presence of artefactual sequences in your reads such as adaptors. Another insight you may obtain from this information are potential biases in the preparation of your library. For example, random hexamer priming is actually not truly random, and preferentially selects certain sequences. The currently popular transposase-based enzymatic protocol, although reasonably random, is also not completely random, and you can see this through positional bias, particularly in the beginning of reads. The presence of adaptors is a relatively common event, and therefore specific plots exist to detect the presence of the most commonly used adaptors. Finally, the presence of repetitive sequences can also suggest contaminants, pcr artifacts, or other types of bias.




**Exercise 6**: Open a terminal. Type 'fastqc' and press enter. The graphical interface of FastQC should appear. Open the file MiSeq_76bp.fastq.gz inside of the folder files. Look at the different plots you obtained. Next, open the file MiSeq_250bp.fastq.gz.

**NOTE**: Given the size of fastq files (usually in the order of Gb), they are most frequently compressed as fastq.gz files. In fact, most tools (such as FastQC) work directly with fastq.gz to reduce space.


<br/>


**Exercise 7**: What are the main differences between the reports of both fastq files?

<details><summary>Click Here to see the answer</summary>
	

The MiSeq_250bp fastq file contains 10000 reads of 250bp, while the MiSeq_76bp contains 1000 reads of 76bp. The MiSeq_250bp reads have a lower per base sequence quality at their end, while the reads of the MiSeq_76bp keep a good quality throughout. The MiSeq_76bp reads contain a very noticeable nucleotide positional bias particularly after position 36. MiSeq_250bp also contain a bit of nucleotide positional bias, but less and only for the first 10bp. The MiSeq_250bp reads display an apparently bimodal GC distribution, while the MiSeq_76bp reads seem closer to a single normal distribution. Finally, MiSeq_76bp contain a clear presence of a known Illumina adaptor after position 36 (probably the reason for the nucleotide positional bias we saw before), while MiSeq_250bp contain a much smaller frequency of another Illumina adaptor towards the ends of the reads.

</p></details>
<br/>




**Exercise 8**: What is the major difference between the two paired fastq files of the paired_example?

<details><summary>Click Here to see the answer</summary>
	
The reverse read has poorer quality bases. This is usually the case, at least for illumina. This is because the reverse reads are generated after the forward reads.

</p></details>
<br/>
<br/>
<br/>


> ## Filtering and Trimming


Like you have FastQC to automatically produce plots from fastq files, you also have software to filter low quality bases from fastq files. [Seqtk](https://github.com/lh3/seqtk) is a very simple tool that you can use to perform this filtering. 

**Exercise 9**: In a terminal, go to folder fastq_examples. Type 'seqtk trimfq -q 0.01 MiSeq_250bp.fastq.gz > MiSeq_250bp.trimmed.fastq'. 

**Exercise 10**: What is this command doing? Use fastQC to check the new fastq file that is created by this command. 

<details><summary>Click Here to see the answer</summary>
	
	Seqtk removes bad quality bases from the ends of reads. In this case, it removes bases with a probability of error greater than 1% (0.01), corresponding to Q<20.
	
</p></details>
<br/>
<br/>

As we saw before, sequencing machines (namely, the illumina ones) require that you add specific sequences (adaptors) to your DNA so that it can be sequenced. For many different reasons, such sequences may end up in your read, and you need to remove these artifacts from your sequences.

<bf/>

**Exercise 11**: How can adaptors appear in your sequences? Take the sample MiSeq_76bp.fastq.gz as an example. 

<details><summary>Click Here to see the answer</summary>
	
	When the fragment being read is smaller than the number of bases the sequencing machine reads, then it will start reading the bases of the adaptor that is attached to all fragments so they can be read by the machines. In the case of MiSeq_76bp, the fragments were all 36bp, and since 76bp were being read, the remaining bases belong to the illumina adaptor that was used.
	
</p></details>
<br/>

There are many programs to remove adaptors from your sequences, such as [cutadapt](https://cutadapt.readthedocs.org/en/stable/). To use them you need to know the adaptors that were used in your library preparation (eg. Illumina TruSeq). For this you need to ask the sequencing center that generated your data.

<br/>

**Exercise 12**
 In MiSeq_76bp.fastq.gz sample, we know that we used the illumina adaptor GTGACTGGAGTTCAGACGTGTGCTCTTCCGATCT, so try to remove this from the 3' end of reads and see the impact of the procedure using FastQC.
 
```{r}
# unzip the file MiSeq_76bp.fastq.gz 

gunzip MiSeq_76bp.fastq.gz

#find if the adaptor is in the sequence
grep "GTGACTGGAGTTCAGACGTGTGCTCTTCCGATCT" MiSeq_76bp.fastq


# count the number of times the sequence matches

grep "GTGACTGGAGTTCAGACGTGTGCTCTTCCGATCT" MiSeq_76bp.fastq |wc -l

```
Do the sequences appear systematically at the beginning or at the end of the reads?

But the adapters could also appear in the reverse, complementary or reverse complementary mode.

Compute the reverse, complementary and the reverse complementary sequences of the two adapters, and find out which of them appear in your data.

To compute those sequences you can use some online resources as the one in:
http://www.bioinformatics.org/sms/rev_comp.html

<details><summary>Click Here to see the answer</summary>
	
```{r}
# find if the adaptor is in the sequence

grep "AGATCGGAAGAGCACACGTCTGAACTCCAGTCAC" MiSeq_76bp.fastq

# count the number of times the sequence matches

grep "AGATCGGAAGAGCACACGTCTGAACTCCAGTCAC" MiSeq_76bp.fastq |wc -l

```
	
</p></details>
<br/>

### Use cutadapt to make an adapter trimming of the reads.

Check the options:

    -a for adapter to the 3’ end.
    -g for adapter to the 5’ end.

you can find  help of the program typing "cutadapt -h" in the shell.

```{r}
cutadapt -a AGATCGGAAGAGCACACGTCTGAACTCCAGTCAC -o MiSeq_76bp.trim.fastq MiSeq_76bp.fastq
cutadapt -g AGATCGGAAGAGCACACGTCTGAACTCCAGTCAC -o MiSeq_76bp.trim2.fastq MiSeq_76bp.trim.fastq

# grep the new files 
grep "AGATCGGAAGAGCACACGTCTGAACTCCAGTCAC" MiSeq_76bp.trim.fastq |wc -l
grep "AGATCGGAAGAGCACACGTCTGAACTCCAGTCAC" MiSeq_76bp.trim2.fastq |wc -l

```
Do a FastQC of the new trimmed files.

<br/>


> ## Alignment
After obtaining millions of short reads, we need to align them to a (sometimes large) reference genome. To achieve this, novel, more efficient, alignment methods had to be developed. One popular method is based on the [burrows-wheeler transform](https://en.wikipedia.org/wiki/Burrows%E2%80%93Wheeler_transform) and the use of efficient data structures, of which [bwa](http://bio-bwa.sourceforge.net/) and [bowtie](http://bowtie-bio.sourceforge.net/index.shtml) are examples. They enable alignment of millions of reads in a few minutes, even in a laptop.

<br/>


    + BWA : BWA is a software package for mapping DNA low-divergent sequences against a large reference genome, such as the human genome. The new project repository is available at GitHub BWA
    + HPG Aligner : HPG Aligner is a new NGS aligner for mapping both DNA Genomic and RNA-seq data against a large reference genome. It’s has been designed for having a high sensitivity and performance.
    + Bowtie2 : Bowtie 2 is an ultrafast and memory-efficient tool for aligning DNA sequencing reads to long reference sequences.
    + TopHat2 : TopHat is a fast splice junction mapper for RNA-Seq reads. It aligns RNA-Seq reads to mammalian-sized genomes using the ultra high-throughput short read aligner Bowtie, and then analyzes the mapping results to identify splice junctions between exons.
    + STAR : STAR aligns RNA-seq reads to a reference genome using uncompressed suffix arrays.



<br/>



**Exercise 13** Create a data folder in your working directory (ex:Alignment) and download the reference genome sequence to be used (human chromosome 21) and simulated datasets from the data folder [alignment](https://www.dropbox.com/sh/4qkqch7gyt888h7/AABD_i9ShwryfAqGeJ0yqqF3a). For this hands-on we are going to use small DNA simulated from chromosome 21 (4 files). Notice that the name of the file describe the dataset, ie. dna_chr21_100_hq stands for: DNA type of data from chromosome 21 with 100pb read lengths of high quality. Where hq quality means 0.1% mutations and lq quality 1% mutations. Take a few minutes to understand the file. 

Working with NGS data requires a high-end workstations and time for building the reference genome indexes and alignment. During this tutorial we will work only with chromosome 21 to speed up the runtimes. You can download it from the Ensembl website ftp://ftp.ensembl.org/pub/release-75/fasta/homo_sapiens/dna/ download the chromosome 21 file (Homo_sapiens.GRCh37.75.dna.chromosome.21.fa.gz) and move it from your browser download folder to your data folder.

**NOTE**: For working with the whole reference genome the file to be downloaded is Homo_sapiens.GRCh37.75.dna.primary_assembly.fa.gz.

For those with access to high-end nodes clusters you can index and simulated whole genome datasets or download real datasets from this sources: - 1000genomes project - European Nucleotide Archive (ENA) - Sequence Read Archive (SRA).

<br/>

In this exercise we’ll learn how to download, install, build the reference genome index and align in single-end and paired-end mode with the one of the most widely DNA aligners: BWA. But first, create an aligners folder to store the software, and an results folder to store the alignment results, create those folders in your working directory next to data, you can create both folders by executing:

```{r}
#inside bwa program create a new folder index
mkdir index

#copy the reference genome to the created folder

#create another folder for the SAM files that you are gone to generate inside your working directory

mkdir results

```

**BAM**
BWA is probably the most used aligner for DNA. AS the documentation states it consists of three different algorithms: BWA, BWA-SW and BWA-MEM. The first algorithm, which is the oldest, is designed for Illumina sequence reads up to 100bp, while the rest two for longer sequences. BWA-MEM and BWA-SW share similar features such as long-read support and split alignment, but BWA-MEM, which is the latest, is generally recommended for high-quality queries as it is faster and more accurate. BWA-MEM also has better performance than BWA for 70-100bp Illumina reads.


**Build the index**


Now you can create the index by executing:

```{r}
bwa index programs/bwa/index/f000_chr21_ref_genome_sequence.fa 

```

**Note1** Some files will be created in the index folder, those files constitute the index that BWA uses.

**Note2**: The index must created only once, it will be used for all the different alignments with BWA.

+ Aligning with new BWA-MEM in both single-end (SE) and paired-end (PE) modes

BWA-MEM is the recommended algorithm to use now. You can check the options by executing:

```{r}
bwa mem

```
To align SE with BWA-MEM execute:

```{r}
bwa mem -t 4 -R "@RG\tID:foo\tSM:bar\tPL:Illumina\tPU:unit1\tLB:lib1" programs/bwa/index/f000_chr21_ref_genome_sequence.fa curso/Dados/dna_chr21_100_hq_read1.fastq > curso/results/bwa/results1.sam

```

To align PE with BAM-MEM just add the second file

```{r}
bwa mem -t 4 -R "@RG\tID:foo\tSM:bar\tPL:Illumina\tPU:unit1\tLB:lib1" programs/bwa/index/f000_chr21_ref_genome_sequence.fa curso/Dados/dna_chr21_100_hq_read1.fastq curso/Dados/dna_chr21_100_hq_read2.fastq > curso/results/bwa/results2.sam
```


> ## The SAM/BAM alignment format

To store millions of alignments, researchers also had to develop new, more practical formats. The [Sequence Alignment/Map (SAM) format](https://samtools.github.io/hts-specs/SAMv1.pdf) is a tabular text file format, where each line contains information for one alignment.
 


**Exercise 14** Open the sam file you generated before (results1.sam) with a text editor, and/or type in the terminal window 'head results1.sam'. To make it easier to analyse you can copy the contents and paste them in a spreadsheet program.

<br/>

SAM files are most often compressed as BAM (Binary SAM) files, to reduce space. These BAM files can then be indexed (do not confuse this indexing with the indexing of the reference genome) to allow direct access to alignments in any arbitrary region of the genome. Several tools only work with BAM files.

**Exercise 15** Let's transform the SAM file into an indexed BAM file. In the same terminal window where you indexed the genome, type 'samtools view -Sb results2.sam > results2.bam'. To create the index, the alignments in the bam file need to be sorted by position. Type 'samtools sort results2.bam  results2.sorted.bam'. Finally, we can create the index 'samtools index results2.sorted.bam'. Notice now the appearance of a companion file results2.sorted.bam.bai that contains the index. This file should always accompany its corresponding bam file.


<br/>
<br/>



> ## Visualize alignments

###  Use Qualimap to assess quality of alignments

After generating alignments and obtaining a SAM/BAM file, how do I know this step went well? The same way as FastQC generates reports of fastq files to assess quality of raw data, there are programs that generate global reports on the quality of alignments. One popular tool for this is [qualimap](http://qualimap.bioinfo.cipf.es/).

**Exercise 16** In the terminal window, in the resequencing folder, type 'qualimap bamqc -bam results2.sorted.bam'. Open the report file generated by qualimap (there is a report html inside a new folder that qualimap creates). Or go to qualimap folder and type ./qualimap it will open an graphic interface program.

+ What information is in a Qualimap report?

<details><summary>Click Here to see the answer</summary>

A Qualimap report includes, among other things:  

  * Number of aligned/mapped reads and other global statistics
  
  * Coverage across the genome and the histogram of coverages
  
  * Number of duplicated sequences (that align exactly to the same place)
  
  * Histogram of mapping quality (how well the reads align, in a Phred scale)
  
  * Distribution of insert size (length of fragments, only available with paired-end alignments)
  
</details><br/>


 
Many of the plots produced by Qualimap are similar to the ones produced by FastQC. There are nonetheless, figures that are specific to alignments. One important figure to look at is the **alignment rate** (percentage of the total reads that align). In this case, we want it to be as close as possible to 100%. In the case of bacterial sequencing or targeted (eg. exonic) sequencing you expect >95% successful alignment, but if sequencing a full mamallian genome (with many duplicated areas) it may be normal to have as low as 70-80% alignment success. Another alignment-specific figure is the **coverage** along the genome. The coverage on a position is the number of reads whose alignment overlap with that position. Another factor to take into account is the amount of duplicated sequences. Usually, duplication levels higher than 20% are not a good sign (they're a sign of low input DNA and PCR artifacts) but again, depends on what you are sequencing and how much. In any of these factors one has to antecipate the expected “quality” for your application.



## Use IGV to visualize the content of a BAM file

You can also directly visualize the alignments using appropriate software such as [IGV](https://www.broadinstitute.org/igv/) or [Tablet](https://ics.hutton.ac.uk/tablet/). 

**Exercise 17** In the terminal window, type 'igv'. Wait some time, and the IGV browser should appear. First, load the reference genome used for the alignment. You should see a chromosome of ~4.8Mb appearing, which is the genome size. Next, load the file results2.sorted.bam. You should see new tracks appearing in IGV when you load a file. 





